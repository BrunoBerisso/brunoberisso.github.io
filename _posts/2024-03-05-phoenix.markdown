---
title:  "Phoenix: the Elixir Django"
date:   2024-02-27 23:54:35 +0000
---

- What is Phoenix
- Why it's cool?
- Hot new use case https://elixir-lang.org/blog/2024/03/05/veeps-elixir-case/

Phoenix

Ok so, what is Phoenix you might ask? Good question! Phoenix is a big framework for building end-to-end web apps. Think of it as ”the Django of the Elixir world” and as such it does everything you might need (and more): server side HTML template rendering, REST API facilities,  DB access, migrations, login, telemetry, etc… but it provides a set of extra features that push me into this madness of fighting with a niche lovely idea like Erlang.

“Channels” https://hexdocs.pm/phoenix/channels.html
Allows you to use your backend as a message broker for your app. You create a topic and hook to it from your clients using web socket or long polling (supported by default if you built your clients inside Phoenix). Once the connection is established a client can connect with any other clients listening to the given topic, or the server can push a message down to one particular client or broadcast across all of them.

The neat thing is: your backend might be a cluster with a handful of nodes, if you and I are connected to the same topic but to different nodes everything will work exactly the same. This allows the backend to scale vertically and horizontally without compromising the feature. In any case, the ceiling running in one box seems to be decently high https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections

The second neat thing is: you can use whatever you want on the client side. You are not required to handle the UI with Phoenix but you could use a native iOS app, a Raspberry Pi, and a web SPA all connect to the same topic.

“Presence” https://hexdocs.pm/phoenix/Phoenix.Presence.html
This builds user-tracking on top of channels. Allows to track if/when an user is connected or not at any given time.

“LiveView”
Using a channel as described before you can seamlessly hook your UI to send commands and receive updates from the backend. The basic mechanism works exactly like React where you have some state in the server that the runtime is watching, when that state is modified Phoenix does a render of your UI, diff with the current state and push an update to only hit the part of the UI that needs to be updated, just like React but server side.

You can hook user events implementations directly to the Elixir code running in the server, so when the user clicks a button you get a method call in your backend instead of an REST API call. But this is particularly great for events not generated by the user like a dashboard showing live updates from an external source, your UI will get chirurgical updates “for free” when the external data changes.

For this to work you will need to handle your UI also using Phoenix, so it knows what state is affecting what part of the UI and how to compute the diff. To do so it provides a template language so you can write things like “<%= for x <- 1..@number do %> x <% end %>” to print a list of “x”, etc..



So… what I’m going to build is a RSS utility with basically two features:
You can add real RSS feeds
You can add a static web page and an XPath expression and get a “feed” from that
It will check for updates every now and then and push them to a Slack channel…somehow, probably with an email address
