---
title:  "Pheeds"
date:   2024-05-14 22:26:08 +0000
---

In previous posts I shared what [I found about Elixr]({% post_url 2024-02-27-elixir_intro %}) while trying to learn [how Phoenix works]({% post_url 2024-03-05-phoenix %}) with the intention of building test application I called **"Pheeds"** (_Ph_oenix + f_eeds_): a simple RSS feed reader that allows the user to add sources of type RSS, Atom or any other static HTML page and it will automatically refresh every now and then.

The _"killer feature"_ here is the HTML support which is done by allowing to set a couple of XPath expressions to extract the content of the page during the sync process. But it has more, it makes heavy use of [LiveView]({% post_url 2024-03-05-phoenix %}#liveview)s... well, all views are _live_ which probably is not the best approach. Anyway, the app is really simple and honestly was a blast to build. Every time I had to do something outside of the main task it always worked on the first try, is also true that getting through the Phoenix docs initially is a PITA to the point that it was the drop that spilled the glass for me to start this blog!

### Conclusions

My impressions of Phoenix and Elixir can't be better, I have a great time building Pheeds and never felt the need to use anything outside of what the ecosystem was providing me. It is true that my app was one level above being a TODO, but even so, I have the sense that everything I could need was just there. I'm talking mostly about `mix` the build tool that comes with Elixir and the tasks that Phoenix ships for it, it allows you to bootstrap new views, add migrations, run tests, etc. I didn't have to choose a migrations approach or investigate how to organize my project because Phoenix does that for me and I highly appreciate it.

Also, Phonenix was built to tackle applications that require near-real-time interactions with many (thousands, millions) concurrent users. Those kinds of systems were the reason why Erlan was invented 40 years ago and that's why [Discord used Elixr to handle 5 million concurrent users](https://discord.com/blog/how-discord-scaled-elixir-to-5-000-000-concurrent-users) and more recently [Veeps migrated to Phoenix to support live events streaming](https://elixir-lang.org/blog/2024/03/05/veeps-elixir-case/) only requiring a team of 4 people. Knowing this I was expecting to have an experience more tailored to those specific scenarios but I found it to be suitable for much more than just that case.

### Simple vs Easy

During the weeks I spent working on this I have always had this idea in the back of my mind, Elixir and Phoenix are not easy pieces of technilogy but they are really simple. As [I mentioned before]({% post_url 2024-02-27-elixir_intro%}#simple-made-easy) Elixir in particular is a simple language with a simple working environment, I was able to produce non-trivial programs within days and I stretch to the more complex ones, like multi-node Elixir clusters, without moving my hands out of the keyboard. That for me is _the_ secret weapon of this development environment: is super powerful and yet super simple.

Phoenix is a little more sophisticated, it's a big framework that has one tool for each job you could possibly face while working on any kind of web-based solutions. It's opinionated in the way it manages configuration and migrations and I found their opinions to match mine so ðŸ‘Œ but even if that's not the case for you it's great to have a starting point to make more informed decisions about what could be a "right" way to do things. The part I found confusing at the beginning is that all the plumbing building your app is based on macros (Elixir has macros ðŸ˜) so it can be hard to understand, once you can spot _what's a macro and what's not_ in your code that problem goes away. 

So, why I never saw Elixir or Phoenix before in the wild during the last 20 years I have been working here?

The explanains I think is that we tend to choose the _easy_ path when we need to pick a tool just because it's easy before even trying to think twice. I get that we all want to do our job and get back to our lifes without make every day a nigthmere, but I also believe that's a recipe for mediocrity and I don't want that for me. More so I think that choosing the easy path automatically has more drawbacks:
- Don't take advantage of new thecnilogies (my last 3 or 4 Java projects used JDK 20 but no new features: no records, no var, etc)
- Get swamped in the same things we know to the point that is hard to spot new ideas/solutions
- Suffer of the _"if all you have is a hammer, everything looks like a nail"_ disease, and you end up using JavaScript to write REST APIs
- Waste a chance to learn something new and get paid for it

## Inverted Conway's Law

Melvin Conway (not to be confused with John Conway) stated this law in [a publication I highly recommend reading](http://www.melconway.com/Home/pdf/committees.pdf):
> Organizations which design systems (in the broad sense used here) are constrained to produce designs which are copies of the communication structures of these organizations.

I found this to be an acurate description of my experience so far in the field and I can see the ramifications of the culture of a company affecting design and implementation desicion to 

Thinking about the impact of the tools we use have 
what tool to choose this is something I usually overlook but I think it makes a lot o sense, on our rush to pick the _easy_ path we will keep talking about our implementations always in the same terms that we arleady know. Think about `git` for example, can you imagine working on a codebase without using branches and commits? I certanly not, even being the case that I didn't use `git` during many years. This for me is a read flag about how importnat is try new things as a team, t

That put us on a hard possition to suggest anything new or out of the box

Pushing this idea a little further I landing in the conclusion that the tools we choose to solve a problem will affect the design of the systems they are going to inahbit in some unexpected ways:
- Shaping conversations between developers
- 